# utils.py

r'''This has the worker-bee functions to generate sounds.

Frequencies are stored and manipulated in log base 2**(1/12) format.  Thus adding 1 moves
up one semitone.  Adding 12 moves up an octave.  Adding 0.01 moves up one cent.  
Zero (0) is C0 and you work your way up from there.  These better match the musical
conception of notes.  They are converted to Hz with the freq_in_Hz function.

The base notes are defined in this module as the global variables C, D, E, F, G,
A, and B.  Also musical intervals are defined as global variables starting with 'm' (for
minor interval) or 'M' for major interval.  These are defined for all intervals, 2 through
7.  Example M3 is a major 3rd.

Getting the internal frequency for a musical note is done with one of the following
functions.  You can adjust the frequency by adding or subtracting intervals or cents.
For example, to add 20 cents to C4: nat(C, 4) + 0.20.
    - nat(base_note, octave)
      - e.g., nat(C, 4)
    - sharp(base_note, octave)
    - flat(base_note, octave)

Numpy arrays are used in two ways here.  In both cases, each element of the array
corresponds with one audio sample time-slot.

    - an array of freqs.  These are the internal freq values.  This array facilitates
      frequency sweeps during the duration of the note.  The length of the array defines
      the length of the note in samples.
        - Frequency envelopes are created by `freq_envelope` which is given the duration
          and starting envelope.  To apply the frequency envelope to a target note, simply
          add the notes value to this array (example, freq_envelope(0.2) + nat(C, 4)).
          - Starting envelopes are generated by:
            - up(interval, duration)
              Generates a frequency curve that starts an interval lower than the target
              frequency and ramps up to the target frequency over duration.
            - down(interval, duration)
              Same as up, but starts an interval higher and ramps down.
        - The `note`(freq_envelope, *harmonics) converts these to an array of the same
          number of amplitude samples as there are frequency samples in the input array.
          The amplitudes are max 1, so need to have a volume applied (note(...) * volume).
        - The `freq_in_Hz` function converts these from an array of internal freq values
          to an array of frequencies in Hz.  You probably won't need this...
    - an array of amplitudes.  This array facilitates amplitude envelopes, such as
      ADSR, during the duration of the note.  These arrays can be combined by simply adding
      them together.  A final volume can be applied by multiplying by the desired volume.
      - adsr(attack, decay, sustain, release, duration)

Harmonics are represented by functions that take a frequency envelope and convert that into
an amplitude envelope for the harmonic.  The harmonic of each frequency sample in the input
envelope is used to generate the output.

    - harmonic(multiplier, ampl_fn=None, ampl_adj=1): creates harmonic function.

      - Example: harmonic(3, ampl_adj=0.5) for 3rd harmonic at 1/2 amplitude.

      - The ampl_fns generate an amplitude based on harmonic multiple:

          - ampl_over_x: sets amplitude to 1/harmonic_multiple
          - ampl_over_x_pow(pow=1): sets amplitude to 1/harmonic_multiple**pow
          - ampl_exp(base=2): sets amplitude to 1/base**harmonic_multiple
'''

import math
import numpy as np
import simpleaudio as sa


Sample_rate = 44100
Delta_t = 1/Sample_rate
Samples_per_segment = 735
Segment_time = 735/44100   # 1/60 sec, 16.66... msec

Semitone = math.pow(2, 1/12)
Ln_semitone = math.log(Semitone)  # base e.  log(x)/Ln_semitone is log x base Semitone.

# Notes (in semitones).
# Octaves go from C to B.
#
#  x x   x x x   x x   x x x
# C D E F G A B C D E F G A B C

C = 0
m2 = 1
D = M2 = 2
m3 = 3
E = M3 = 4
F = m4 = 5
M4 = m5 = 6
G = M5 = 7
m6 = 8
A = M6 = 9
m7 = 10
B = M7 = 11

# Middle C is C4.
# C0 is the lowest note here (16.4Hz).
# E0 is 20.6Hz.
# B9 is the highest note here (15804Hz).
# E10 would be 21096Hz.

A4_freq = 440  # A above middle C
C4_freq = A4_freq / Semitone**9
C0_freq = C4_freq / Semitone**(12*4)

Freq_offset = math.log(C0_freq) / Ln_semitone

#print(f"{A4_freq=}, {C4_freq=}, {C0_freq=}, {Freq_offset=}")

Notes = {
    'A': A, 'B': B, 'C': C, 'D': D, 'E': E, 'F': F, 'G': G,
    'm3': m3, 'M3': M3, 'm4': m4, 'M4': M4, 'm5': m5, 'M5': M5,
    'm6': m6, 'M6': M6, 'm7': m7, 'M7': M7,
    's1': 1, 's2': 2, 's3': 3, 's4': 4, 's5': 5, 's6': 6,
    's7': 7, 's8': 8, 's9': 9, 's10': 10, 's11': 11, 's12': 2,
    'o1': 12, 'o2': 12*2, 'o3': 12*3, 'o4': 12*4,
}

# get timesteps for each sample, T is note duration in seconds
#T = 0.25
T = 0.5


def freq_in_Hz(f):
    r'''Translate internal freq value to Hz.
    '''
    return np.exp((f + Freq_offset) * Ln_semitone)


def down(interval, duration=0.1):
    r'''Generates an array of freq intervals to create a decending attack.

    The attack interval goes from time 0 to `duration` (in secs), decending
    in freq from `interval` to just before unity.

    The number of samples generated is truncated from duration * Sample_rate.
    '''
    #print("drop", "interval", interval, "duration", duration)
    # np.linspace(start, stop, num, endpoint)
    ans = np.linspace(interval, 0, int(duration * Sample_rate), False)
    print("down: len(ans)", len(ans), "ans", ans)
    return ans


def up(interval, duration=0.1):
    r'''Generates an array of freq intervals to create a ascending attack.

    The attack interval goes from time 0 to `duration` (in secs), ascending
    in freq from -interval to just before unity.

    The number of samples generated is truncated from duration * Sample_rate.
    '''
    num_samples = int(duration * Sample_rate)
    ans = np.linspace(-interval, 0, num_samples, False)
    print("up: len(ans)", len(ans), "ans", ans)
    return ans


def freq_envelope(duration=T, attack=None):
    r'''Returns array of freqs, one per sample.

    Add note to the result, e.g.: freq_envelope(0.2) + nat(C, 3)
    '''
    if attack is None:
        attack = ()
    return np.hstack((attack,
                      np.zeros(int(duration * Sample_rate) - len(attack))))


def note(freqs, *harmonics):
    r'''Converts freqs to relative amplitudes (max 1).
    '''
    base = np.sin(np.cumsum(freq_in_Hz(freqs) * Delta_t) * (2 * np.pi))
    for h in harmonics:
        base += h(freqs)
    return base


def harmonic(multiplier, ampl_fn=None, ampl_adj=1):
    r'''Returns a harmonic function.

    The harmonic function generates the haramonic amplitude envelope for any given freq
    envelope.
    '''
    if ampl_fn is None:
        amplitude = ampl_adj
    else:
        amplitude = ampl_fn(multiplier) * ampl_adj
    print("harmonic", multiplier, amplitude)
    return lambda freqs: \
             note(freqs + math.log(multiplier)/Ln_semitone) * amplitude


def ampl_over_x(h):
    return 1/h

def ampl_over_x_pow(pow=1):
    return lambda h: 1/h**pow

def ampl_exp(base=2):
    return lambda h: math.pow(base, -h)

ampl_fns = {
    "ampl_over_x": ampl_over_x,
    "ampl_over_x_pow:": ampl_over_x_pow,
    "ampl_exp:": ampl_exp,
}

def adsr(attack, decay, sustain, release, duration=T):
    r'''Returns an amplitude envelope for duration seconds.

    attack, decay and release are in seconds.
    sustain is an amplitude (relative to peak=1).
    '''
    assert 0 <= sustain <= 1
    durt = int(duration * Sample_rate)
    rt = int(release * Sample_rate)
    assert rt < durt
    at = int(attack * Sample_rate)
    a = np.linspace(1 / at, 1, at, True)
    if at >= durt - rt:
        print("Cut short during attack phase!")
        at = durt - rt
        a = a[:at]
        r = np.geomspace(a[-1], 1/2**16, rt, False)
        return np.hstack((a, r))
    dt = int(decay * Sample_rate)
    d = np.geomspace(1, sustain, dt, False)
    if dt > durt - at - rt:
        print("Cut short during decay phase!")
        dt = durt - at - rt
        d = d[:dt]
        r = np.geomspace(d[-1], 1/2**16, rt, False)
        return np.hstack((a, d, r))
    r = np.geomspace(sustain, 1/2**16, rt, False)
    st = durt - at - dt - rt
    s = np.ones(st) * sustain
    return np.hstack((a, d, s, r))


# natural
def nat(base_note, octave=4):
    return base_note + 12*octave


def sharp(base_note, octave=4):
    return base_note + 12*octave + 1


def flat(base_note, octave=4):
    return base_note + 12*octave - 1


def sin(f, t):
    r'''Generate sine wave notes.

    t is expected to an array of linear time values.

    f may be a scalar or an array of freq values of the same length as t.

    Returns an array of amplitude values (max 1).
    '''
    return np.sin(f * (2 * np.pi) * t)


def play(audio):
    # normalize to 16-bit range
    max_ampl = np.max(np.abs(audio))
    print("play: max_ampl", max_ampl)
    audio *= 32767 / max_ampl
    # convert to 16-bit data
    audio = audio.astype(np.int16)

    # start playback
    # sa.play_buffer(audio_data, num_channels, bytes_per_sample, Sample_rate)
    play_obj = sa.play_buffer(audio, 1, 2, Sample_rate)

    # wait for playback to finish before exiting
    play_obj.wait_done()



if __name__ == "__main__":
    print(f"{Freq_offset=}")
    print(f"{freq_in_Hz(nat(E,0))=}")
    print(f"{freq_in_Hz(nat(C,4))=}")
    print(f"{freq_in_Hz(nat(A,4))=}")
    print(f"{freq_in_Hz(nat(B,0))=}")
    print(f"{freq_in_Hz(nat(B,9)+5)=}")
    print(f"{down(m3, 10*Delta_t)=}")
    print(f"{up(m3, 10*Delta_t)=}")
